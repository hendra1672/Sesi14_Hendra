export const createEmptyStats = (items) => items.reduce((acc, item) => ({ ...acc, [item]: 0 }), {});
export const createEmptySeries = (items) => items.reduce((acc, item) => ({ ...acc, [item]: [] }), {});
export const normalizeStatistic = (statistic, itemType) => {
    return itemType.reduce((acc, item) => {
        acc[item] = statistic[item] ?? 0;
        return acc;
    }, {});
};
const calculateRawValues = (stats, executionId, itemType) => {
    const points = {};
    const series = createEmptySeries(itemType);
    itemType.forEach((item) => {
        const pointId = `${executionId}-${item}`;
        const value = stats[item] ?? 0;
        points[pointId] = {
            x: executionId,
            y: value,
        };
        series[item].push(pointId);
    });
    return { points, series };
};
const calculatePercentValues = (stats, executionId, itemType) => {
    const points = {};
    const series = createEmptySeries(itemType);
    const values = Object.values(stats);
    const total = values.reduce((sum, value) => sum + value, 0);
    if (total === 0) {
        return { points, series };
    }
    itemType.forEach((item) => {
        const pointId = `${executionId}-${item}`;
        const value = stats[item] ?? 0;
        points[pointId] = {
            x: executionId,
            y: (value / total) * 100,
        };
        series[item].push(pointId);
    });
    return { points, series };
};
export const mergeTrendDataGeneric = (trendData, trendDataPart, itemType) => {
    return {
        ...trendData,
        points: {
            ...trendData.points,
            ...trendDataPart.points,
        },
        slices: {
            ...trendData.slices,
            ...trendDataPart.slices,
        },
        series: Object.entries(trendDataPart.series).reduce((series, [group, pointIds]) => {
            if (Array.isArray(pointIds)) {
                return {
                    ...series,
                    [group]: [...(trendData.series?.[group] || []), ...pointIds],
                };
            }
            return series;
        }, trendData.series || createEmptySeries(itemType)),
        min: Math.min(trendData.min ?? Infinity, trendDataPart.min),
        max: Math.max(trendData.max ?? -Infinity, trendDataPart.max),
    };
};
export const getTrendDataGeneric = (stats, reportName, executionOrder, itemType, chartOptions) => {
    const { type, dataType, title, mode = "raw", metadata = {} } = chartOptions;
    const { executionIdAccessor, executionNameAccessor } = metadata;
    const executionId = executionIdAccessor ? executionIdAccessor(executionOrder) : `execution-${executionOrder}`;
    const { points, series } = mode === "percent"
        ? calculatePercentValues(stats, executionId, itemType)
        : calculateRawValues(stats, executionId, itemType);
    const slices = {};
    const pointsAsArray = Object.values(points);
    const pointsCount = pointsAsArray.length;
    const values = pointsAsArray.map((point) => point.y);
    const min = pointsCount ? Math.min(...values) : 0;
    const max = pointsCount ? Math.max(...values) : 0;
    if (pointsCount > 0) {
        const executionName = executionNameAccessor ? executionNameAccessor(executionOrder) : reportName;
        slices[executionId] = {
            min,
            max,
            metadata: {
                executionId,
                executionName,
            },
        };
    }
    return {
        type,
        dataType,
        title,
        points,
        slices,
        series,
        min,
        max,
    };
};
